// CSG.js
class CSG{constructor(){this.polygons=[]}clone(){let csg=new CSG();csg.polygons=this.polygons.map(p=>p.clone());return csg}toPolygons(){return this.polygons}union(csg){let a=new Node(this.clone().polygons);let b=new Node(csg.clone().polygons);a.clipTo(b);b.clipTo(a);b.invert();b.clipTo(a);b.invert();a.build(b.allPolygons());return CSG.fromPolygons(a.allPolygons())}subtract(csg){let a=new Node(this.clone().polygons);let b=new Node(csg.clone().polygons);a.invert();a.clipTo(b);b.clipTo(a);b.invert();b.clipTo(a);b.invert();a.build(b.allPolygons());a.invert();return CSG.fromPolygons(a.allPolygons())}intersect(csg){let a=new Node(this.clone().polygons);let b=new Node(csg.clone().polygons);a.invert();b.clipTo(a);b.invert();a.clipTo(b);b.clipTo(a);a.build(b.allPolygons());a.invert();return CSG.fromPolygons(a.allPolygons())}inverse(){let csg=this.clone();csg.polygons.map(p=>p.flip());return csg}static fromPolygons(polygons){let csg=new CSG();csg.polygons=polygons;return csg}static fromGeometry(geom){let polys=[];if(geom.isGeometry){let fs=geom.faces;let vs=geom.vertices;let fm=['a','b','c'];for(let i=0;i<fs.length;i++){let f=fs[i];let vertices=[];for(let j=0;j<3;j++)vertices.push(new Vertex(vs[f[fm[j]]],f.vertexNormals[j],geom.faceVertexUvs[0][i][j]));polys.push(new Polygon(vertices))}}else if(geom.isBufferGeometry){let vertices=[],normals=[],uvs=[];let posattr=geom.attributes.position;let normalattr=geom.attributes.normal;let uvattr=geom.attributes.uv;let colorattr=geom.attributes.color;let index;if(geom.index)index=geom.index.array;else{index=new Array((posattr.array.length/posattr.itemSize)|0);for(let i=0;i<index.length;i++)index[i]=i}let triCount=index.length/3;for(let i=0,pli=0,l=index.length;i<l;i+=3,pli+=2){let vertices=[];for(let j=0;j<3;j++){let vi=index[i+j];let vp=vi*3;let vt=vi*2;let x=posattr.array[vp];let y=posattr.array[vp+1];let z=posattr.array[vp+2];let nx=normalattr.array[vp];let ny=normalattr.array[vp+1];let nz=normalattr.array[vp+2];let u=uvattr.array[vt];let v=uvattr.array[vt+1];vertices.push(new Vertex(new Vector3(x,y,z),new Vector3(nx,ny,nz),new Vector2(u,v)));}polys.push(new Polygon(vertices));}}return CSG.fromPolygons(polys)}static toGeometry(csg,toMatrix){let triCount=0;csg.polygons.forEach(p=>{triCount+=(p.vertices.length-2)});let geom=new Geometry();let vertices=[];let normals=[];let uvs=[];let colors=[];let faces=[];let vertCount=0;csg.polygons.forEach(p=>{let pverts=p.vertices;let pvlen=pverts.length;for(let j=3;j<=pvlen;j++){faces.push(new Face3(vertCount,vertCount+j-2,vertCount+j-1));vertices.push(pverts[0].pos);vertices.push(pverts[j-2].pos);vertices.push(pverts[j-1].pos);normals.push(pverts[0].normal);normals.push(pverts[j-2].normal);normals.push(pverts[j-1].normal);uvs.push(pverts[0].uv);uvs.push(pverts[j-2].uv);uvs.push(pverts[j-1].uv);if(colors&&pverts[0].color){colors.push(pverts[0].color);colors.push(pverts[j-2].color);colors.push(pverts[j-1].color);}}});geom.vertices=vertices;geom.faces=faces;geom.faceVertexUvs[0]=uvs;geom.computeVertexNormals();if(toMatrix){geom.vertices.forEach(v=>v.applyMatrix4(toMatrix))}return geom}static toMesh(csg,toMatrix,toMaterial){let geom=CSG.toGeometry(csg,toMatrix);let mesh=new Mesh(geom,toMaterial);mesh.position.set(0,0,0);return mesh}static fromMesh(mesh){let geom=mesh.geometry.clone();geom.applyMatrix4(mesh.matrix);let csg=CSG.fromGeometry(geom);return csg}}class Vertex{constructor(pos,normal,uv,color){this.pos=new Vector3().copy(pos);this.normal=new Vector3().copy(normal);this.uv=new Vector2().copy(uv);this.uv.y=1-this.uv.y;if(color)this.color=new Vector3().copy(color)}clone(){return new Vertex(this.pos,this.normal,this.uv)}flip(){this.normal.multiplyScalar(-1)}interpolate(other,t){return new Vertex(this.pos.clone().lerp(other.pos,t),this.normal.clone().lerp(other.normal,t),this.uv.clone().lerp(other.uv,t))}}class Plane{constructor(normal,w){this.normal=normal;this.w=w}clone(){return new Plane(this.normal.clone(),this.w)}flip(){this.normal.multiplyScalar(-1);this.w=-this.w}splitPolygon(polygon,coplanarFront,coplanarBack,front,back){let COPLANAR=0;let FRONT=1;let BACK=2;let SPANNING=3;let polygonType=0;let types=[];for(let i=0;i<polygon.vertices.length;i++){let t=this.normal.dot(polygon.vertices[i].pos)-this.w;let type=t<-1e-5?BACK:t>1e-5?FRONT:COPLANAR;polygonType|=type;types.push(type)}switch(polygonType){case COPLANAR:if(this.normal.dot(polygon.plane.normal)>0)coplanarFront.push(polygon);else coplanarBack.push(polygon);break;case FRONT:front.push(polygon);break;case BACK:back.push(polygon);break;case SPANNING:let f=[],b=[];for(let i=0;i<polygon.vertices.length;i++){let j=(i+1)%polygon.vertices.length;let ti=types[i],tj=types[j];let vi=polygon.vertices[i],vj=polygon.vertices[j];if(ti!=BACK)f.push(vi);if(ti!=FRONT)b.push(ti!=BACK?vi.clone():vi);if((ti|tj)==SPANNING){let t=(this.w-this.normal.dot(vi.pos))/this.normal.dot(vj.pos.clone().sub(vi.pos));let v=vi.interpolate(vj,t);f.push(v);b.push(v.clone())}}if(f.length>=3)front.push(new Polygon(f));if(b.length>=3)back.push(new Polygon(b));break;}}}class Polygon{constructor(vertices){this.vertices=vertices;let a=vertices[0].pos.clone().sub(vertices[1].pos);let b=vertices[2].pos.clone().sub(vertices[1].pos);this.plane=new Plane(a.cross(b).normalize(),this.plane?this.plane.w:vertices[0].pos.clone().dot(this.plane.normal))}clone(){return new Polygon(this.vertices.map(v=>v.clone()))}flip(){this.vertices.reverse().map(v=>v.flip());this.plane.flip()}}class Node{constructor(polygons){this.plane=null;this.front=null;this.back=null;this.polygons=[];if(polygons)this.build(polygons)}clone(){let node=new Node();node.plane=this.plane&&this.plane.clone();node.front=this.front&&this.front.clone();node.back=this.back&&this.back.clone();node.polygons=this.polygons.map(p=>p.clone());return node}invert(){for(let i=0;i<this.polygons.length;i++)this.polygons[i].flip();this.plane.flip();if(this.front)this.front.invert();if(this.back)this.back.invert();let temp=this.front;this.front=this.back;this.back=temp}clipPolygons(polygons){if(!this.plane)return polygons.slice();let front=[],back=[];for(let i=0;i<polygons.length;i++){this.plane.splitPolygon(polygons[i],[],[],front,back)}if(this.front)front=this.front.clipPolygons(front);if(this.back)back=this.back.clipPolygons(back);else back=[];return front.concat(back)}clipTo(bsp){this.polygons=bsp.clipPolygons(this.polygons);if(this.front)this.front.clipTo(bsp);if(this.back)this.back.clipTo(bsp)}allPolygons(){let polygons=this.polygons.slice();if(this.front)polygons=polygons.concat(this.front.allPolygons());if(this.back)polygons=polygons.concat(this.back.allPolygons());return polygons}build(polygons){if(!polygons.length)return;if(!this.plane)this.plane=polygons[0].plane.clone();let front=[],back=[];for(let i=0;i<polygons.length;i++){this.plane.splitPolygon(polygons[i],this.polygons,this.polygons,front,back)}if(front.length){if(!this.front)this.front=new Node();this.front.build(front)}if(back.length){if(!this.back)this.back=new Node();this.back.build(back)}}}if(typeof module!=='undefined')module.exports=CSG;